diff --git a/README.md b/README.md
index 1f7e7be..b021e43 100644
--- a/README.md
+++ b/README.md
@@ -10,7 +10,6 @@ This repo contains a **pure-Python** pipeline to compute:
   - `MOS_*_v3d`: Visual3D tutorial (Closest_Bound) style — distance to the *closest* BoS bound in AP/ML
     (`MOS_AP_v3d`, `MOS_ML_v3d`, `MOS_v3d`)
   - `MOS_*_dir`: backward-compatible alias of `MOS_*_v3d` (same values)
-  - `MOS_*_velDir`: legacy velocity-direction switching (debug; can jump when vCOM crosses 0)
 
 ## Important constraints (matching your V3D tutorial logic)
 
diff --git a/gpt_pro.md b/gpt_pro.md
index c82da44..aba5e6f 100644
--- a/gpt_pro.md
+++ b/gpt_pro.md
@@ -1,42 +1,34 @@
-지금 네 repo에서 **MOS_AP_dir / MOS_ML_dir 라인이 “거의 90도”로 꺾여 보이는 이유는 로직이 V3D(Visual3D) 튜토리얼 방식이 아니라**, 매 프레임마다 **vCOM 부호로 ‘어느 쪽 bound를 쓸지’ 스위칭**하고 있기 때문이야.
-
-* vCOM이 0 근처에서 조금만 흔들려도(필터링/노이즈/미분 때문에 흔함) **min bound ↔ max bound가 프레임마다 바뀜**
-* 그러면 MOS가 “가까운 bound까지의 거리”가 아니라, 갑자기 “반대편 bound까지의 거리”로 튀어서 **계단/수직에 가까운 점프**가 생김
-* Visual3D 튜토리얼의 “Original definition”은 이런 스위칭이 아니라 **두 bound(예: minX, maxX)에 대한 거리 중 더 작은 값(Closest_Bound)**을 선택해 **연속적인(=튀지 않는) MoS**를 만들도록 설명돼 있어. ([wiki.has-motion.com][1])
-
-그래서 “V3D 방식대로” 바꾸려면 핵심은 이거야:
-
-## 네 의도(설계 의도) 정리
-
-1. **V3D 튜토리얼(Original definition)처럼**
-
-   * AP, ML 각각에서 **BoS bound 두 개(min/max)**에 대한 거리를 계산하고
-   * 매 프레임 **더 작은 값(closest bound)**을 MoS로 사용한다. ([wiki.has-motion.com][1])
-
-2. 네 기존 코드에서 쓰던 `MOS_AP_dir`, `MOS_ML_dir` 이름은 그대로 두되(분석/plot 호환성 때문에),
-   **이 값이 이제부터는 V3D closest-bound 값**이 되도록 바꾼다.
-   → 너가 지금 쓰는 “MOS_AP_dir plot” 그대로 다시 그려도 정상 곡선이 나와야 함.
-
-3. 기존 “vCOM 부호 스위칭” 방식은 완전히 버리진 않고,
-   **디버그용으로 `MOS_AP_velDir`, `MOS_ML_velDir`로 따로 남겨** 비교 가능하게 한다.
-   (이 값은 계속 점프가 생길 수 있음)
-
-4. V3D가 “single value MoS”를 말할 때 흔히 쓰는 것처럼,
-   `MOS_v3d = min(MOS_AP_v3d, MOS_ML_v3d)`도 같이 제공한다. ([wiki.has-motion.com][1])
-
----
-
-## 구현 위치(코드 변경)
+지금 네 repo에서 **MOS_AP_dir / MOS_ML_dir 라인이 “거의 90도”로 꺾여 보였던 이유는**, 과거 구현이 V3D(Visual3D) 튜토리얼의 *Original definition*과 다르게 매 프레임 **vCOM 부호로 ‘어느 쪽 bound를 쓸지’ 스위칭**했기 때문이야.
+
+* vCOM이 0 근처에서 조금만 흔들려도(필터링/노이즈/미분 때문에 흔함) **min bound ↔ max bound가 프레임마다 바뀜**
+* 그러면 MOS가 “가까운 bound까지의 거리”가 아니라, 갑자기 “반대편 bound까지의 거리”로 튀어서 **계단/수직에 가까운 점프**가 생김
+* Visual3D 튜토리얼의 “Original definition”은 이런 스위칭이 아니라 **두 bound(예: minX, maxX)에 대한 거리 중 더 작은 값(Closest_Bound)**을 선택해 **연속적인(=튀지 않는) MoS**를 만들도록 설명돼 있어. ([wiki.has-motion.com][1])
+
+그래서 “V3D 방식대로” 맞추려면 핵심은 이거야:
+
+## 네 의도(설계 의도) 정리
+
+1. **V3D 튜토리얼(Original definition)처럼**
 
-현재 repo에는 아래 변경이 반영되어 있어(= **V3D Closest_Bound 방식으로 MoS(AP/ML) 계산**).
+   * AP, ML 각각에서 **BoS bound 두 개(min/max)**에 대한 거리를 계산하고
+   * 매 프레임 **더 작은 값(closest bound)**을 MoS로 사용한다. ([wiki.has-motion.com][1])
 
-* 변경 파일:
+2. 네 기존 코드에서 쓰던 `MOS_AP_dir`, `MOS_ML_dir` 이름은 그대로 두되(분석/plot 호환성 때문에),
+   **이 값이 이제부터는 V3D closest-bound 값**이 되도록 정의한다.
+   → 너가 지금 쓰는 “MOS_AP_dir plot” 그대로 다시 그려도 정상 곡선이 나와야 함.
+
+3. V3D가 “single value MoS”를 말할 때 흔히 쓰는 것처럼,
+   `MOS_v3d = min(MOS_AP_v3d, MOS_ML_v3d)`도 같이 제공한다. ([wiki.has-motion.com][1])
+
+---
+
+## 구현 위치(코드 변경)
 
-  * `src/replace_v3d/mos/core.py`  ✅ 핵심 로직 수정
-  * `scripts/run_mos_pipeline.py` ✅ 출력 컬럼 + summary에 v3d 지표 추가
-  * `scripts/run_batch_mos_timeseries_csv.py` ✅ 배치 CSV 컬럼 추가
-  * `scripts/run_batch_all_timeseries_csv.py` ✅ 통합 배치 CSV 컬럼 추가
-  * `README.md` ✅ 컬럼 의미 업데이트
+* `src/replace_v3d/mos/core.py`  ✅ 핵심 로직
+* `scripts/run_mos_pipeline.py` ✅ 출력 컬럼 + summary
+* `scripts/run_batch_mos_timeseries_csv.py` ✅ 배치 CSV 컬럼
+* `scripts/run_batch_all_timeseries_csv.py` ✅ 통합 배치 CSV 컬럼
+* `README.md` ✅ 컬럼 의미
 
 ---
 
@@ -62,36 +54,23 @@ conda run -n module python scripts/run_batch_mos_timeseries_csv.py \
 ```
 
 ---
-
-## 적용 후 “뭘 plot 해야 정상인지”
-
-이제부터 추천 plot:
-
-* **정상(=V3D)**
-
-  * `MOS_AP_v3d` (또는 `MOS_AP_dir` — 둘은 동일값)
-  * `MOS_ML_v3d` (또는 `MOS_ML_dir`)
-  * `MOS_v3d`
-
-* **비교/디버그(=예전 방식, 점프 가능)**
-
-  * `MOS_AP_velDir`
-  * `MOS_ML_velDir`
-
-즉, 네가 지금 보던 “MOS_AP_dir 라인이 수직에 가깝다” 문제는
-변경 반영 후에는 **MOS_AP_dir 자체가 V3D값(closest-bound)으로 바뀌어서** 바로 해결되어야 해.
-
----
-
+
+## 적용 후 “뭘 plot 해야 정상인지”
+
+추천 plot:
+
+* `MOS_AP_v3d` (또는 `MOS_AP_dir` — 둘은 동일값)
+* `MOS_ML_v3d` (또는 `MOS_ML_dir`)
+* `MOS_v3d`
+
+즉, 네가 보던 “MOS_AP_dir 라인이 수직에 가깝다” 문제는
+**MOS_AP_dir 자체가 V3D값(closest-bound)으로 정의되면** 해결돼야 해.
+
+---
+
 ## 변경이 바꾸는 핵심(한 줄 요약)
-
-* **Before:** `MOS_AP_dir` = (vCOM 부호로 minX/maxX 선택) → 0 근처에서 계속 뒤집혀 점프
-* **After:** `MOS_AP_dir` = `min(x-minX, maxX-x)` (Closest_Bound) → 연속적, V3D 튜토리얼과 동일한 선택 방식 ([wiki.has-motion.com][1])
-  (예전 방식은 `MOS_AP_velDir`로 분리)
-
----
-
-원하면, 네가 지금 쓰는 그 엑셀/CSV(패치 적용 전/후)를 기준으로
-`MOS_AP_dir` vs `MOS_AP_velDir`를 한 그림에 겹쳐서 “왜 수직처럼 보였는지”를 프레임 레벨로 딱 짚어줄 수도 있어.
-
-[1]: https://wiki.has-motion.com/doku.php?id=visual3d%3Atutorials%3Aknowledge_discovery%3Aassesing_stability_during_gait "Assesing Stability During Gait [HAS-Motion Software Documentation]"
+
+* **Before:** `MOS_AP_dir` = (vCOM 부호로 minX/maxX 선택) → 0 근처에서 계속 뒤집혀 점프
+* **After:** `MOS_AP_dir` = `min(x-minX, maxX-x)` (Closest_Bound) → 연속적, V3D 튜토리얼과 동일한 선택 방식 ([wiki.has-motion.com][1])
+
+[1]: https://wiki.has-motion.com/doku.php?id=visual3d%3Atutorials%3Aknowledge_discovery%3Aassesing_stability_during_gait "Assesing Stability During Gait [HAS-Motion Software Documentation]"
diff --git a/replace_V3D_v3d_mos_patch.diff b/replace_V3D_v3d_mos_patch.diff
deleted file mode 100644
index 2837603..0000000
--- a/replace_V3D_v3d_mos_patch.diff
+++ /dev/null
@@ -1,336 +0,0 @@
-diff --git a/README.md b/README.md
-index 789b4b6..1f7e7be 100644
---- a/README.md
-+++ b/README.md
-@@ -5,7 +5,12 @@ This repo contains a **pure-Python** pipeline to compute:
- - **COM** (segment-based, De Leva mass fractions + simple marker-defined segment geometry)
- - **XCoM / xCOM** (Hof: `xCOM = COM + vCOM / ω0`, `ω0 = sqrt(g/leg_length)`)
- - **BoS** polygon (foot landmark markers → convex hull on the ground plane)
--- **MoS** (signed minimum distance from xCOM to BoS polygon boundary)
-+- **MoS**
-+  - `MOS_minDist_signed`: signed minimum distance from xCOM to BoS polygon boundary (+inside, -outside)
-+  - `MOS_*_v3d`: Visual3D tutorial (Closest_Bound) style — distance to the *closest* BoS bound in AP/ML
-+    (`MOS_AP_v3d`, `MOS_ML_v3d`, `MOS_v3d`)
-+  - `MOS_*_dir`: backward-compatible alias of `MOS_*_v3d` (same values)
-+  - `MOS_*_velDir`: legacy velocity-direction switching (debug; can jump when vCOM crosses 0)
- 
- ## Important constraints (matching your V3D tutorial logic)
- 
-@@ -47,7 +52,8 @@ Options:
- 
- Output:
- - `output/all_trials_mos_timeseries.csv` (long-format; one row per `subject-velocity-trial` x `MocapFrame`)
--- Key columns include `subject-velocity-trial`, `MocapFrame`, `COM_*`, `vCOM_*`, `xCOM_*`, `BOS_*`, `MOS_*`.
-+- Key columns include `subject-velocity-trial`, `MocapFrame`, `COM_*`, `vCOM_*`, `xCOM_*`, `BOS_*`, `MOS_*`
-+  (notably: `MOS_minDist_signed`, `MOS_AP_v3d`, `MOS_ML_v3d`, `MOS_v3d`).
- 
- ## Quick start (batch unified time series CSV: MOS + joint angles + ankle torque)
- 
-diff --git a/scripts/run_batch_all_timeseries_csv.py b/scripts/run_batch_all_timeseries_csv.py
-index d66fbf8..a7b386a 100644
---- a/scripts/run_batch_all_timeseries_csv.py
-+++ b/scripts/run_batch_all_timeseries_csv.py
-@@ -93,8 +93,13 @@ def _make_timeseries_dataframe(
-         "BOS_minY": mos.BOS_minY,
-         "BOS_maxY": mos.BOS_maxY,
-         "MOS_minDist_signed": mos.MOS_signed,
-+        "MOS_AP_v3d": mos.MOS_AP_v3d,
-+        "MOS_ML_v3d": mos.MOS_ML_v3d,
-+        "MOS_v3d": mos.MOS_v3d,
-         "MOS_AP_dir": mos.MOS_AP_dir,
-         "MOS_ML_dir": mos.MOS_ML_dir,
-+        "MOS_AP_velDir": mos.MOS_AP_velDir,
-+        "MOS_ML_velDir": mos.MOS_ML_velDir,
-         "Is_platform_onset_frame": is_platform_onset,
-         "Is_step_onset_frame": is_step_onset,
-         # Joint angles (Visual3D-like)
-diff --git a/scripts/run_batch_mos_timeseries_csv.py b/scripts/run_batch_mos_timeseries_csv.py
-index 6b4956b..2869fa2 100644
---- a/scripts/run_batch_mos_timeseries_csv.py
-+++ b/scripts/run_batch_mos_timeseries_csv.py
-@@ -84,8 +84,13 @@ def _make_timeseries_dataframe(
-         "BOS_minY": mos.BOS_minY,
-         "BOS_maxY": mos.BOS_maxY,
-         "MOS_minDist_signed": mos.MOS_signed,
-+        "MOS_AP_v3d": mos.MOS_AP_v3d,
-+        "MOS_ML_v3d": mos.MOS_ML_v3d,
-+        "MOS_v3d": mos.MOS_v3d,
-         "MOS_AP_dir": mos.MOS_AP_dir,
-         "MOS_ML_dir": mos.MOS_ML_dir,
-+        "MOS_AP_velDir": mos.MOS_AP_velDir,
-+        "MOS_ML_velDir": mos.MOS_ML_velDir,
-         "Is_platform_onset_frame": is_platform_onset,
-         "Is_step_onset_frame": is_step_onset,
-     }
-diff --git a/scripts/run_mos_pipeline.py b/scripts/run_mos_pipeline.py
-index 1691cc8..ba12965 100644
---- a/scripts/run_mos_pipeline.py
-+++ b/scripts/run_mos_pipeline.py
-@@ -146,8 +146,13 @@ def main() -> None:
-             "BOS_minY": mos.BOS_minY,
-             "BOS_maxY": mos.BOS_maxY,
-             "MOS_minDist_signed": mos.MOS_signed,
-+            "MOS_AP_v3d": mos.MOS_AP_v3d,
-+            "MOS_ML_v3d": mos.MOS_ML_v3d,
-+            "MOS_v3d": mos.MOS_v3d,
-             "MOS_AP_dir": mos.MOS_AP_dir,
-             "MOS_ML_dir": mos.MOS_ML_dir,
-+            "MOS_AP_velDir": mos.MOS_AP_velDir,
-+            "MOS_ML_velDir": mos.MOS_ML_velDir,
-             "Is_platform_onset_frame": is_platform_onset,
-             "Is_step_onset_frame": is_step_onset,
-         }
-@@ -178,19 +183,31 @@ def main() -> None:
-         "platform_onset_local": events.platform_onset_local,
-         "step_onset_local": events.step_onset_local,
-         "analysis_end_local": end_frame,
-+        # Polygon-signed MoS (convex hull boundary)
-         "baseline_MOS_mean": float(baseline_df.select(pl.col("MOS_minDist_signed").mean()).item()),
-         "baseline_MOS_min": float(baseline_df.select(pl.col("MOS_minDist_signed").min()).item()),
-         "perturb_MOS_min": float(pert_df.select(pl.col("MOS_minDist_signed").min()).item()),
-+        # Visual3D original-style MoS (closest bound)
-+        "baseline_MOS_v3d_mean": float(baseline_df.select(pl.col("MOS_v3d").mean()).item()),
-+        "baseline_MOS_v3d_min": float(baseline_df.select(pl.col("MOS_v3d").min()).item()),
-+        "perturb_MOS_v3d_min": float(pert_df.select(pl.col("MOS_v3d").min()).item()),
-     }
- 
-     if pert_df.height > 0:
-+        onset_time = float(df_pl.filter(pl.col("Is_platform_onset_frame")).select(pl.col("Time_s")).item())
-+
-+        # Polygon-signed MoS min
-         min_row = pert_df.sort("MOS_minDist_signed").head(1)
-         summary["perturb_MOS_min_frame"] = int(min_row.select(pl.col("Frame")).item())
--
--        onset_time = float(df_pl.filter(pl.col("Is_platform_onset_frame")).select(pl.col("Time_s")).item())
-         min_time = float(min_row.select(pl.col("Time_s")).item())
-         summary["perturb_MOS_min_time_from_onset_s"] = float(min_time - onset_time)
- 
-+        # Visual3D closest-bound MoS min
-+        min_row_v3d = pert_df.sort("MOS_v3d").head(1)
-+        summary["perturb_MOS_v3d_min_frame"] = int(min_row_v3d.select(pl.col("Frame")).item())
-+        min_time_v3d = float(min_row_v3d.select(pl.col("Time_s")).item())
-+        summary["perturb_MOS_v3d_min_time_from_onset_s"] = float(min_time_v3d - onset_time)
-+
-     # Optional V3D COM validation
-     validation = None
-     if args.v3d_com_xlsx:
-diff --git a/src/replace_v3d/mos/core.py b/src/replace_v3d/mos/core.py
-index 96b09b9..97e1e97 100644
---- a/src/replace_v3d/mos/core.py
-+++ b/src/replace_v3d/mos/core.py
-@@ -27,9 +27,52 @@ BOS_MARKERS_DEFAULT = [
- 
- @dataclass(frozen=True)
- class MOSResult:
-+    """MoS / BoS time series container.
-+
-+    Notes
-+    -----
-+    Visual3D's MoS tutorial ("Original definition") uses the distance from xCoM to
-+    the *closest* BoS boundary at each frame (via the Closest_Bound meta-command).
-+
-+    Your old implementation used a *velocity-sign switch* (pick minX vs maxX based
-+    on vCOM sign). That is not Visual3D's logic, and it produces step-like jumps
-+    whenever vCOM crosses 0 (which can happen frequently due to filtering noise).
-+
-+    This repo now exposes:
-+
-+    - MOS_AP_v3d / MOS_ML_v3d / MOS_v3d:
-+        Visual3D-style closest-bound distances (recommended).
-+
-+    - MOS_AP_dir / MOS_ML_dir:
-+        Backward-compatible aliases of the Visual3D-style values above.
-+        (Kept because downstream scripts/plots often referenced "*_dir".)
-+
-+    - MOS_AP_velDir / MOS_ML_velDir:
-+        The previous velocity-switching version (debug only).
-+
-+    - MOS_signed:
-+        Polygon-based signed min distance to the convex hull boundary (+inside).
-+        This is *not* the same as Visual3D's original scalar MoS, but can be
-+        useful for convex-hull distance analysis.
-+    """
-+
-+    # Polygon signed min distance (convex hull boundary)
-     MOS_signed: np.ndarray  # (T,)
-+
-+    # Visual3D (original) style: closest bound in each direction
-+    MOS_AP_v3d: np.ndarray  # (T,)
-+    MOS_ML_v3d: np.ndarray  # (T,)
-+    MOS_v3d: np.ndarray  # (T,)
-+
-+    # Backward-compatible aliases (same as MOS_*_v3d)
-     MOS_AP_dir: np.ndarray  # (T,)
-     MOS_ML_dir: np.ndarray  # (T,)
-+
-+    # Legacy: velocity-direction based bound selection (debug; discontinuous)
-+    MOS_AP_velDir: np.ndarray  # (T,)
-+    MOS_ML_velDir: np.ndarray  # (T,)
-+
-+    # BoS geometry summaries
-     BOS_area: np.ndarray  # (T,)
-     BOS_minX: np.ndarray  # (T,)
-     BOS_maxX: np.ndarray  # (T,)
-@@ -37,6 +80,23 @@ class MOSResult:
-     BOS_maxY: np.ndarray  # (T,)
- 
- 
-+def _closest_bound_1d(x: float, xmin: float, xmax: float) -> float:
-+    """Signed distance to the closest of two bounds.
-+
-+    Returns
-+    -------
-+    d : float
-+        Positive if xmin <= x <= xmax, negative otherwise.
-+
-+    Notes
-+    -----
-+    This matches Visual3D's "Closest_Bound" behavior for two candidate bounds
-+    at each frame (take the smaller of the two distances).
-+    """
-+
-+    return min(x - xmin, xmax - x)
-+
-+
- def compute_mos_timeseries(
-     points: np.ndarray,
-     labels: List[str],
-@@ -45,19 +105,49 @@ def compute_mos_timeseries(
-     end_frame: Optional[int] = None,
-     bos_markers: List[str] = BOS_MARKERS_DEFAULT,
- ) -> MOSResult:
--    """Compute MoS for each frame using:
-+    """Compute MoS for each frame.
-+
-+    BoS
-+    ---
-+    - BoS polygon is the convex hull of foot-landmark markers (ground plane: X-Y)
-+    - Also returns axis-aligned bounds (minX/maxX/minY/maxY) of that hull
-+
-+    MoS outputs
-+    ---
-+    - MOS_signed: signed min distance from xCOM(XY) to hull boundary (+inside)
-+
-+    - MOS_AP_v3d / MOS_ML_v3d:
-+        Visual3D "original" style closest-bound distance.
-+
-+    - MOS_v3d:
-+        min(MOS_AP_v3d, MOS_ML_v3d)  (closest boundary overall)
-+
-+    - MOS_AP_dir / MOS_ML_dir:
-+        Aliases of MOS_AP_v3d / MOS_ML_v3d (for backward compatibility)
- 
--    - xCOM (Hof) as the test point
--    - BoS as the convex hull of foot-landmark markers (ground plane: X-Y)
--    - MoS = signed minimum distance to the BoS boundary
-+    - MOS_AP_velDir / MOS_ML_velDir:
-+        Legacy velocity-direction switching (debug only)
- 
-     Parameters
-     ----------
--    points: (T, N, 3)
--    xcom:   (T, 3)
--    vcom:   (T, 3)
--    end_frame: if provided, compute only frames [1..end_frame] (1-based)
-+    points:
-+        (T, N, 3)
-+    labels:
-+        list of marker labels of length N
-+    xcom:
-+        (T, 3)
-+    vcom:
-+        (T, 3)
-+    end_frame:
-+        If provided, compute only frames [1..end_frame] (1-based)
-+    bos_markers:
-+        Marker names used to form the BoS hull.
-+
-+    Returns
-+    -------
-+    MOSResult
-     """
-+
-     T = points.shape[0]
-     if end_frame is None:
-         end = T
-@@ -72,8 +162,19 @@ def compute_mos_timeseries(
-         idx.append(labels.index(m))
- 
-     MOS_signed = np.zeros(end, dtype=float)
--    MOS_AP = np.zeros(end, dtype=float)
--    MOS_ML = np.zeros(end, dtype=float)
-+
-+    MOS_AP_v3d = np.zeros(end, dtype=float)
-+    MOS_ML_v3d = np.zeros(end, dtype=float)
-+    MOS_v3d = np.zeros(end, dtype=float)
-+
-+    # Backward-compat aliases (filled at the end)
-+    MOS_AP_dir = np.zeros(end, dtype=float)
-+    MOS_ML_dir = np.zeros(end, dtype=float)
-+
-+    # Legacy velocity-switching (debug)
-+    MOS_AP_velDir = np.zeros(end, dtype=float)
-+    MOS_ML_velDir = np.zeros(end, dtype=float)
-+
-     area = np.zeros(end, dtype=float)
-     minX = np.zeros(end, dtype=float)
-     maxX = np.zeros(end, dtype=float)
-@@ -81,7 +182,7 @@ def compute_mos_timeseries(
-     maxY = np.zeros(end, dtype=float)
- 
-     for t in range(end):
--        pts_xy = points[t, idx, :2]  # (8,2)
-+        pts_xy = points[t, idx, :2]  # (M,2)
- 
-         hull = convex_hull_2d(pts_xy)
-         area[t] = polygon_area(hull)
-@@ -91,27 +192,39 @@ def compute_mos_timeseries(
-         p = xcom[t, :2]
-         MOS_signed[t] = signed_min_distance_point_to_polygon(p, hull)
- 
--        # Directional margins (optional but useful): boundary in direction of COM velocity
--        # X axis: A/P, negative X = forward in your coordinate description.
-+        # Visual3D "original" style = closest bound (no velocity switching)
-+        # NOTE: In this repo's coordinate setup, X is A/P and Y is M/L (see plan.md).
-+        MOS_AP_v3d[t] = _closest_bound_1d(float(p[0]), bminx, bmaxx)
-+        MOS_ML_v3d[t] = _closest_bound_1d(float(p[1]), bminy, bmaxy)
-+        MOS_v3d[t] = min(MOS_AP_v3d[t], MOS_ML_v3d[t])
-+
-+        # Legacy: velocity-direction switching (debug only)
-         if vcom[t, 0] < 0:
--            MOS_AP[t] = p[0] - bminx
-+            MOS_AP_velDir[t] = p[0] - bminx
-         else:
--            MOS_AP[t] = bmaxx - p[0]
-+            MOS_AP_velDir[t] = bmaxx - p[0]
- 
--        # Y axis: M/L (sign depends on setup; keep consistent with raw data)
-         if vcom[t, 1] < 0:
--            MOS_ML[t] = p[1] - bminy
-+            MOS_ML_velDir[t] = p[1] - bminy
-         else:
--            MOS_ML[t] = bmaxy - p[1]
-+            MOS_ML_velDir[t] = bmaxy - p[1]
-+
-+    # Backward-compat aliases
-+    MOS_AP_dir[:] = MOS_AP_v3d
-+    MOS_ML_dir[:] = MOS_ML_v3d
- 
-     return MOSResult(
-         MOS_signed=MOS_signed,
--        MOS_AP_dir=MOS_AP,
--        MOS_ML_dir=MOS_ML,
-+        MOS_AP_v3d=MOS_AP_v3d,
-+        MOS_ML_v3d=MOS_ML_v3d,
-+        MOS_v3d=MOS_v3d,
-+        MOS_AP_dir=MOS_AP_dir,
-+        MOS_ML_dir=MOS_ML_dir,
-+        MOS_AP_velDir=MOS_AP_velDir,
-+        MOS_ML_velDir=MOS_ML_velDir,
-         BOS_area=area,
-         BOS_minX=minX,
-         BOS_maxX=maxX,
-         BOS_minY=minY,
-         BOS_maxY=maxY,
-     )
--
diff --git a/scripts/run_batch_all_timeseries_csv.py b/scripts/run_batch_all_timeseries_csv.py
index e5668fd..bfda4b0 100644
--- a/scripts/run_batch_all_timeseries_csv.py
+++ b/scripts/run_batch_all_timeseries_csv.py
@@ -101,8 +101,6 @@ def _make_timeseries_dataframe(
         "MOS_v3d": mos.MOS_v3d,
         "MOS_AP_dir": mos.MOS_AP_dir,
         "MOS_ML_dir": mos.MOS_ML_dir,
-        "MOS_AP_velDir": mos.MOS_AP_velDir,
-        "MOS_ML_velDir": mos.MOS_ML_velDir,
         "Is_platform_onset_frame": is_platform_onset,
         "Is_step_onset_frame": is_step_onset,
         # Joint angles (Visual3D-like)
diff --git a/scripts/run_batch_mos_timeseries_csv.py b/scripts/run_batch_mos_timeseries_csv.py
index 2869fa2..40be08b 100644
--- a/scripts/run_batch_mos_timeseries_csv.py
+++ b/scripts/run_batch_mos_timeseries_csv.py
@@ -89,8 +89,6 @@ def _make_timeseries_dataframe(
         "MOS_v3d": mos.MOS_v3d,
         "MOS_AP_dir": mos.MOS_AP_dir,
         "MOS_ML_dir": mos.MOS_ML_dir,
-        "MOS_AP_velDir": mos.MOS_AP_velDir,
-        "MOS_ML_velDir": mos.MOS_ML_velDir,
         "Is_platform_onset_frame": is_platform_onset,
         "Is_step_onset_frame": is_step_onset,
     }
diff --git a/scripts/run_mos_pipeline.py b/scripts/run_mos_pipeline.py
index ba12965..5c2a47e 100644
--- a/scripts/run_mos_pipeline.py
+++ b/scripts/run_mos_pipeline.py
@@ -151,8 +151,6 @@ def main() -> None:
             "MOS_v3d": mos.MOS_v3d,
             "MOS_AP_dir": mos.MOS_AP_dir,
             "MOS_ML_dir": mos.MOS_ML_dir,
-            "MOS_AP_velDir": mos.MOS_AP_velDir,
-            "MOS_ML_velDir": mos.MOS_ML_velDir,
             "Is_platform_onset_frame": is_platform_onset,
             "Is_step_onset_frame": is_step_onset,
         }
diff --git a/src/replace_v3d/mos/core.py b/src/replace_v3d/mos/core.py
index 97e1e97..5bab5f0 100644
--- a/src/replace_v3d/mos/core.py
+++ b/src/replace_v3d/mos/core.py
@@ -34,26 +34,19 @@ class MOSResult:
     Visual3D's MoS tutorial ("Original definition") uses the distance from xCoM to
     the *closest* BoS boundary at each frame (via the Closest_Bound meta-command).
 
-    Your old implementation used a *velocity-sign switch* (pick minX vs maxX based
-    on vCOM sign). That is not Visual3D's logic, and it produces step-like jumps
-    whenever vCOM crosses 0 (which can happen frequently due to filtering noise).
-
-    This repo now exposes:
+    This repo exposes:
 
     - MOS_AP_v3d / MOS_ML_v3d / MOS_v3d:
-        Visual3D-style closest-bound distances (recommended).
+        Visual3D-style closest-bound distances.
 
     - MOS_AP_dir / MOS_ML_dir:
-        Backward-compatible aliases of the Visual3D-style values above.
+        Backward-compatible aliases of MOS_AP_v3d / MOS_ML_v3d (same values).
         (Kept because downstream scripts/plots often referenced "*_dir".)
 
-    - MOS_AP_velDir / MOS_ML_velDir:
-        The previous velocity-switching version (debug only).
-
     - MOS_signed:
         Polygon-based signed min distance to the convex hull boundary (+inside).
-        This is *not* the same as Visual3D's original scalar MoS, but can be
-        useful for convex-hull distance analysis.
+        This is not identical to Visual3D's original scalar MoS, but can be useful
+        for convex-hull distance analysis.
     """
 
     # Polygon signed min distance (convex hull boundary)
@@ -68,10 +61,6 @@ class MOSResult:
     MOS_AP_dir: np.ndarray  # (T,)
     MOS_ML_dir: np.ndarray  # (T,)
 
-    # Legacy: velocity-direction based bound selection (debug; discontinuous)
-    MOS_AP_velDir: np.ndarray  # (T,)
-    MOS_ML_velDir: np.ndarray  # (T,)
-
     # BoS geometry summaries
     BOS_area: np.ndarray  # (T,)
     BOS_minX: np.ndarray  # (T,)
@@ -114,7 +103,8 @@ def compute_mos_timeseries(
 
     MoS outputs
     ---
-    - MOS_signed: signed min distance from xCOM(XY) to hull boundary (+inside)
+    - MOS_signed:
+        Signed min distance from xCOM(XY) to hull boundary (+inside)
 
     - MOS_AP_v3d / MOS_ML_v3d:
         Visual3D "original" style closest-bound distance.
@@ -125,9 +115,6 @@ def compute_mos_timeseries(
     - MOS_AP_dir / MOS_ML_dir:
         Aliases of MOS_AP_v3d / MOS_ML_v3d (for backward compatibility)
 
-    - MOS_AP_velDir / MOS_ML_velDir:
-        Legacy velocity-direction switching (debug only)
-
     Parameters
     ----------
     points:
@@ -138,6 +125,7 @@ def compute_mos_timeseries(
         (T, 3)
     vcom:
         (T, 3)
+        (unused in V3D closest-bound MoS; kept for backward-compatible call sites)
     end_frame:
         If provided, compute only frames [1..end_frame] (1-based)
     bos_markers:
@@ -171,10 +159,6 @@ def compute_mos_timeseries(
     MOS_AP_dir = np.zeros(end, dtype=float)
     MOS_ML_dir = np.zeros(end, dtype=float)
 
-    # Legacy velocity-switching (debug)
-    MOS_AP_velDir = np.zeros(end, dtype=float)
-    MOS_ML_velDir = np.zeros(end, dtype=float)
-
     area = np.zeros(end, dtype=float)
     minX = np.zeros(end, dtype=float)
     maxX = np.zeros(end, dtype=float)
@@ -198,17 +182,6 @@ def compute_mos_timeseries(
         MOS_ML_v3d[t] = _closest_bound_1d(float(p[1]), bminy, bmaxy)
         MOS_v3d[t] = min(MOS_AP_v3d[t], MOS_ML_v3d[t])
 
-        # Legacy: velocity-direction switching (debug only)
-        if vcom[t, 0] < 0:
-            MOS_AP_velDir[t] = p[0] - bminx
-        else:
-            MOS_AP_velDir[t] = bmaxx - p[0]
-
-        if vcom[t, 1] < 0:
-            MOS_ML_velDir[t] = p[1] - bminy
-        else:
-            MOS_ML_velDir[t] = bmaxy - p[1]
-
     # Backward-compat aliases
     MOS_AP_dir[:] = MOS_AP_v3d
     MOS_ML_dir[:] = MOS_ML_v3d
@@ -220,8 +193,6 @@ def compute_mos_timeseries(
         MOS_v3d=MOS_v3d,
         MOS_AP_dir=MOS_AP_dir,
         MOS_ML_dir=MOS_ML_dir,
-        MOS_AP_velDir=MOS_AP_velDir,
-        MOS_ML_velDir=MOS_ML_velDir,
         BOS_area=area,
         BOS_minX=minX,
         BOS_maxX=maxX,
