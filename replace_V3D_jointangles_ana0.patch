diff --git a/scripts/run_batch_all_timeseries_csv.py b/scripts/run_batch_all_timeseries_csv.py
index d66fbf8..09d37c9 100644
--- a/scripts/run_batch_all_timeseries_csv.py
+++ b/scripts/run_batch_all_timeseries_csv.py
@@ -30,6 +30,7 @@ from replace_v3d.events import (
     resolve_subject_from_token,
 )
 from replace_v3d.joint_angles.v3d_joint_angles import compute_v3d_joint_angles_3d
+from replace_v3d.joint_angles.postprocess import postprocess_joint_angles
 from replace_v3d.mos import compute_mos_timeseries
 from replace_v3d.torque.ankle_torque import compute_ankle_torque_from_net_wrench
 from replace_v3d.torque.cop import compute_cop_lab
@@ -58,6 +59,7 @@ def _make_timeseries_dataframe(
     xCOM: np.ndarray,
     mos: Any,
     angles: Any,
+    angles_ana0: dict[str, np.ndarray] | None = None,
     torque_payload: dict[str, np.ndarray],
 ) -> pd.DataFrame:
     mocap_frames = np.arange(1, end_frame + 1, dtype=int)
@@ -124,6 +126,12 @@ def _make_timeseries_dataframe(
         "Neck_Z_deg": angles.neck_Z,
     }
 
+    # Optional: analysis-friendly joint angles (sign-unified + baseline-subtracted).
+    # These columns get suffix `_ana0` to avoid breaking existing schemas.
+    if angles_ana0 is not None:
+        for k, v in angles_ana0.items():
+            payload[k] = v
+
     for key, values in torque_payload.items():
         payload[key] = values
 
@@ -347,6 +355,14 @@ def main() -> None:
         default="utf-8-sig",
         help="CSV text encoding (default: utf-8-sig; recommended for Korean text in Excel).",
     )
+    parser.add_argument(
+        "--angles_ana0",
+        action="store_true",
+        help=(
+            "Also export analysis-friendly joint angles with suffix `_ana0`: "
+            "LEFT Y/Z sign-unified + quiet-standing baseline removed (frames 1..11)."
+        ),
+    )
     parser.add_argument(
         "--max_files",
         type=int,
@@ -474,6 +490,50 @@ def main() -> None:
 
             angles = compute_v3d_joint_angles_3d(c3d.points, c3d.labels, end_frame=end_frame)
 
+            angles_ana0_payload: dict[str, np.ndarray] | None = None
+            if args.angles_ana0:
+                # Build an angles-only DF and apply the same postprocess used by the
+                # single-trial joint angle script.
+                mocap_frames = np.arange(1, end_frame + 1, dtype=int)
+                df_angles = pl.DataFrame(
+                    {
+                        "MocapFrame": mocap_frames,
+                        "Hip_L_X_deg": angles.hip_L_X,
+                        "Hip_L_Y_deg": angles.hip_L_Y,
+                        "Hip_L_Z_deg": angles.hip_L_Z,
+                        "Hip_R_X_deg": angles.hip_R_X,
+                        "Hip_R_Y_deg": angles.hip_R_Y,
+                        "Hip_R_Z_deg": angles.hip_R_Z,
+                        "Knee_L_X_deg": angles.knee_L_X,
+                        "Knee_L_Y_deg": angles.knee_L_Y,
+                        "Knee_L_Z_deg": angles.knee_L_Z,
+                        "Knee_R_X_deg": angles.knee_R_X,
+                        "Knee_R_Y_deg": angles.knee_R_Y,
+                        "Knee_R_Z_deg": angles.knee_R_Z,
+                        "Ankle_L_X_deg": angles.ankle_L_X,
+                        "Ankle_L_Y_deg": angles.ankle_L_Y,
+                        "Ankle_L_Z_deg": angles.ankle_L_Z,
+                        "Ankle_R_X_deg": angles.ankle_R_X,
+                        "Ankle_R_Y_deg": angles.ankle_R_Y,
+                        "Ankle_R_Z_deg": angles.ankle_R_Z,
+                        "Trunk_X_deg": angles.trunk_X,
+                        "Trunk_Y_deg": angles.trunk_Y,
+                        "Trunk_Z_deg": angles.trunk_Z,
+                        "Neck_X_deg": angles.neck_X,
+                        "Neck_Y_deg": angles.neck_Y,
+                        "Neck_Z_deg": angles.neck_Z,
+                    }
+                )
+
+                df_pp, _meta_pp = postprocess_joint_angles(
+                    df_angles,
+                    frame_col="MocapFrame",
+                    unify_lr_sign=True,
+                    baseline_frames=(1, 11),
+                )
+                angle_cols = [c for c in df_pp.columns if c.endswith("_deg")]
+                angles_ana0_payload = {f"{c}_ana0": df_pp[c].to_numpy() for c in angle_cols}
+
             df_ts = _make_timeseries_dataframe(
                 subject=subject,
                 velocity=velocity,
@@ -487,6 +547,7 @@ def main() -> None:
                 xCOM=xCOM,
                 mos=mos,
                 angles=angles,
+                angles_ana0=angles_ana0_payload,
                 torque_payload=torque_payload,
             )
 
diff --git a/scripts/run_joint_angles_pipeline.py b/scripts/run_joint_angles_pipeline.py
index b7e7b31..d3d5ab9 100644
--- a/scripts/run_joint_angles_pipeline.py
+++ b/scripts/run_joint_angles_pipeline.py
@@ -16,6 +16,7 @@ from replace_v3d.c3d_reader import read_c3d_points
 from replace_v3d.cli.trial_resolve import resolve_velocity_trial
 from replace_v3d.events import load_trial_events, parse_trial_from_filename
 from replace_v3d.joint_angles.v3d_joint_angles import compute_v3d_joint_angles_3d
+from replace_v3d.joint_angles.postprocess import postprocess_joint_angles
 
 
 def main() -> None:
@@ -97,15 +98,39 @@ def main() -> None:
         }
     )
 
+    # ---------------------------------------------------------------------
+    # Optional analysis-friendly post-process (does NOT affect the raw CSV).
+    #
+    # Why:
+    # - Visual3D-style RHR joint angles often show L/R sign differences in Y/Z.
+    # - Static offsets are common; subtracting quiet-standing baseline is useful.
+    #
+    # Default baseline window uses frame numbers [1..11] which corresponds to
+    # python indices [0..10] (your note: data[0,10] is quiet standing).
+    # ---------------------------------------------------------------------
+    df_pl_ana0, meta_pp = postprocess_joint_angles(
+        df_pl,
+        frame_col="Frame",
+        unify_lr_sign=True,
+        baseline_frames=(1, 11),
+    )
+
     out_csv = out_dir / f"{c3d_path.stem}_JOINT_ANGLES_preStep.csv"
     out_xlsx = out_dir / f"{c3d_path.stem}_JOINT_ANGLES_preStep.xlsx"
 
+    # Post-processed outputs (extra; safe for analysis but not for MD5 validation)
+    out_csv_ana0 = out_dir / f"{c3d_path.stem}_JOINT_ANGLES_preStep_ana0.csv"
+
     # CSV first (stable for MD5)
     # NOTE: Use pandas formatting for stable exponent padding (e.g., e-07),
     # matching the provided reference CSV used for MD5 validation.
     df = df_pl.to_pandas()
     df.to_csv(out_csv, index=False)
 
+    # Post-processed CSV (same schema, but sign-unified + baseline-subtracted)
+    df_ana0 = df_pl_ana0.to_pandas()
+    df_ana0.to_csv(out_csv_ana0, index=False)
+
     # Excel (for inspection)
     meta = {
         "Trial": c3d_path.stem,
@@ -125,10 +150,15 @@ def main() -> None:
 
     with pd.ExcelWriter(out_xlsx, engine="openpyxl") as writer:
         df.to_excel(writer, sheet_name="timeseries_preStep", index=False)
+        df_ana0.to_excel(writer, sheet_name="timeseries_preStep_ana0", index=False)
         pl.DataFrame([meta]).to_pandas().to_excel(writer, sheet_name="meta", index=False)
+        pl.DataFrame([meta_pp.__dict__]).to_pandas().to_excel(
+            writer, sheet_name="meta_postprocess", index=False
+        )
         pl.DataFrame([vars(events)]).to_pandas().to_excel(writer, sheet_name="events", index=False)
 
     print(f"[OK] Saved: {out_csv}")
+    print(f"[OK] Saved: {out_csv_ana0}")
     print(f"[OK] Saved: {out_xlsx}")
 
 
diff --git a/src/replace_v3d/joint_angles/__init__.py b/src/replace_v3d/joint_angles/__init__.py
index 4bdb8d8..970d979 100644
--- a/src/replace_v3d/joint_angles/__init__.py
+++ b/src/replace_v3d/joint_angles/__init__.py
@@ -2,10 +2,13 @@
 
 from .sagittal import LowerLimbAngles, compute_lower_limb_angles
 from .v3d_joint_angles import V3DJointAngles3D, compute_v3d_joint_angles_3d
+from .postprocess import JointAnglePostprocessMeta, postprocess_joint_angles
 
 __all__ = [
     "LowerLimbAngles",
     "compute_lower_limb_angles",
     "V3DJointAngles3D",
     "compute_v3d_joint_angles_3d",
+    "JointAnglePostprocessMeta",
+    "postprocess_joint_angles",
 ]
diff --git a/src/replace_v3d/joint_angles/postprocess.py b/src/replace_v3d/joint_angles/postprocess.py
new file mode 100644
index 0000000..65d1775
--- /dev/null
+++ b/src/replace_v3d/joint_angles/postprocess.py
@@ -0,0 +1,139 @@
+"""Post-processing helpers for Visual3D-like joint angle outputs.
+
+This module is intentionally *post* (i.e., it does not change the underlying
+segment definitions / joint angle math). It exists because:
+
+1) Visual3D-style RHR joint angles often produce left/right sign differences
+   in Y/Z (ab/adduction + internal/external rotation) even during quiet
+   standing.
+2) In marker-based pipelines, a small static offset can remain due to segment
+   coordinate system (SCS) misalignment; subtracting a quiet-standing baseline
+   is a common way to compare changes (Î”angle) across sides/trials.
+
+The repo keeps the raw joint angle CSV schema unchanged for MD5 validation.
+Use these helpers to generate an additional, analysis-friendly output.
+"""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+from typing import Iterable, Sequence
+
+import polars as pl
+
+
+@dataclass(frozen=True)
+class JointAnglePostprocessMeta:
+    """Metadata returned by :func:`postprocess_joint_angles`.
+
+    Notes
+    -----
+    * `baseline_values` stores the mean of the selected baseline window
+      **after** applying sign-unification (if enabled). This is what is
+      subtracted from the time series.
+    """
+
+    frame_col: str
+    baseline_frame_start: int
+    baseline_frame_end: int
+    flipped_columns: tuple[str, ...]
+    baseline_values: dict[str, float]
+
+
+def _default_flip_columns(columns: Sequence[str]) -> list[str]:
+    """Default 'anatomical sign unification' columns.
+
+    Convention used here (common Visual3D practice):
+    - keep X (flex/ext) as-is
+    - flip LEFT Y/Z so that Y/Z have the same sign meaning as the RIGHT side
+
+    This targets Hip/Knee/Ankle only and is applied only if the column exists.
+    """
+
+    candidates = []
+    for joint in ("Hip", "Knee", "Ankle"):
+        for axis in ("Y", "Z"):
+            candidates.append(f"{joint}_L_{axis}_deg")
+    return [c for c in candidates if c in columns]
+
+
+def postprocess_joint_angles(
+    df: pl.DataFrame,
+    *,
+    frame_col: str = "Frame",
+    unify_lr_sign: bool = True,
+    baseline_frames: tuple[int, int] | None = (1, 11),
+    flip_columns: Iterable[str] | None = None,
+) -> tuple[pl.DataFrame, JointAnglePostprocessMeta]:
+    """Apply analysis-friendly post-processing to a joint angle time series.
+
+    Parameters
+    ----------
+    df:
+        Polars DataFrame containing a frame column and angle columns.
+    frame_col:
+        Name of the frame index column (e.g., ``"Frame"`` or ``"MocapFrame"``).
+    unify_lr_sign:
+        If True, flips selected LEFT Y/Z columns (multiplies by -1) so that
+        left/right have consistent sign meaning.
+    baseline_frames:
+        If provided, subtract the mean of each angle column over this inclusive
+        frame window ``(start, end)``.
+
+        The default (1, 11) corresponds to python indices [0..10] used in
+        your note: ``data[0,10]``.
+    flip_columns:
+        Optional explicit list of columns to flip. If None, uses the default
+        Visual3D-like set (Hip/Knee/Ankle LEFT Y/Z).
+
+    Returns
+    -------
+    df_out, meta
+        Postprocessed DataFrame (same columns) and metadata.
+    """
+
+    if frame_col not in df.columns:
+        raise KeyError(f"Frame column not found: {frame_col!r}")
+
+    # Angle columns: operate only on *_deg to avoid touching Frame/Time columns.
+    angle_cols = [c for c in df.columns if c.endswith("_deg")]
+
+    flipped: list[str] = []
+    out = df
+
+    # 1) Sign unification (LEFT Y/Z)
+    if unify_lr_sign:
+        flip_cols = list(flip_columns) if flip_columns is not None else _default_flip_columns(df.columns)
+        if flip_cols:
+            out = out.with_columns([(-pl.col(c)).alias(c) for c in flip_cols])
+            flipped = flip_cols
+
+    # 2) Baseline subtraction
+    baseline_values: dict[str, float] = {}
+    if baseline_frames is not None:
+        b0, b1 = int(baseline_frames[0]), int(baseline_frames[1])
+        if b1 < b0:
+            raise ValueError(f"baseline_frames must satisfy end>=start. Got {baseline_frames!r}")
+
+        base_df = out.filter(pl.col(frame_col).is_between(b0, b1, closed="both"))
+        if base_df.height == 0:
+            raise ValueError(
+                f"No rows found for baseline window {baseline_frames!r} "
+                f"using frame_col={frame_col!r}."
+            )
+
+        # mean() returns a 1-row DF
+        base_row = base_df.select([pl.col(c).mean().alias(c) for c in angle_cols]).row(0)
+        baseline_values = {c: float(v) for c, v in zip(angle_cols, base_row)}
+
+        out = out.with_columns([(pl.col(c) - pl.lit(baseline_values[c])).alias(c) for c in angle_cols])
+
+    meta = JointAnglePostprocessMeta(
+        frame_col=str(frame_col),
+        baseline_frame_start=int(baseline_frames[0]) if baseline_frames is not None else -1,
+        baseline_frame_end=int(baseline_frames[1]) if baseline_frames is not None else -1,
+        flipped_columns=tuple(flipped),
+        baseline_values=baseline_values,
+    )
+
+    return out, meta
