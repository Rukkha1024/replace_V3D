diff --git a/README.md b/README.md
index 789b4b6..1f7e7be 100644
--- a/README.md
+++ b/README.md
@@ -5,7 +5,12 @@ This repo contains a **pure-Python** pipeline to compute:
 - **COM** (segment-based, De Leva mass fractions + simple marker-defined segment geometry)
 - **XCoM / xCOM** (Hof: `xCOM = COM + vCOM / ω0`, `ω0 = sqrt(g/leg_length)`)
 - **BoS** polygon (foot landmark markers → convex hull on the ground plane)
-- **MoS** (signed minimum distance from xCOM to BoS polygon boundary)
+- **MoS**
+  - `MOS_minDist_signed`: signed minimum distance from xCOM to BoS polygon boundary (+inside, -outside)
+  - `MOS_*_v3d`: Visual3D tutorial (Closest_Bound) style — distance to the *closest* BoS bound in AP/ML
+    (`MOS_AP_v3d`, `MOS_ML_v3d`, `MOS_v3d`)
+  - `MOS_*_dir`: backward-compatible alias of `MOS_*_v3d` (same values)
+  - `MOS_*_velDir`: legacy velocity-direction switching (debug; can jump when vCOM crosses 0)
 
 ## Important constraints (matching your V3D tutorial logic)
 
@@ -47,7 +52,8 @@ Options:
 
 Output:
 - `output/all_trials_mos_timeseries.csv` (long-format; one row per `subject-velocity-trial` x `MocapFrame`)
-- Key columns include `subject-velocity-trial`, `MocapFrame`, `COM_*`, `vCOM_*`, `xCOM_*`, `BOS_*`, `MOS_*`.
+- Key columns include `subject-velocity-trial`, `MocapFrame`, `COM_*`, `vCOM_*`, `xCOM_*`, `BOS_*`, `MOS_*`
+  (notably: `MOS_minDist_signed`, `MOS_AP_v3d`, `MOS_ML_v3d`, `MOS_v3d`).
 
 ## Quick start (batch unified time series CSV: MOS + joint angles + ankle torque)
 
diff --git a/scripts/run_batch_all_timeseries_csv.py b/scripts/run_batch_all_timeseries_csv.py
index d66fbf8..a7b386a 100644
--- a/scripts/run_batch_all_timeseries_csv.py
+++ b/scripts/run_batch_all_timeseries_csv.py
@@ -93,8 +93,13 @@ def _make_timeseries_dataframe(
         "BOS_minY": mos.BOS_minY,
         "BOS_maxY": mos.BOS_maxY,
         "MOS_minDist_signed": mos.MOS_signed,
+        "MOS_AP_v3d": mos.MOS_AP_v3d,
+        "MOS_ML_v3d": mos.MOS_ML_v3d,
+        "MOS_v3d": mos.MOS_v3d,
         "MOS_AP_dir": mos.MOS_AP_dir,
         "MOS_ML_dir": mos.MOS_ML_dir,
+        "MOS_AP_velDir": mos.MOS_AP_velDir,
+        "MOS_ML_velDir": mos.MOS_ML_velDir,
         "Is_platform_onset_frame": is_platform_onset,
         "Is_step_onset_frame": is_step_onset,
         # Joint angles (Visual3D-like)
diff --git a/scripts/run_batch_mos_timeseries_csv.py b/scripts/run_batch_mos_timeseries_csv.py
index 6b4956b..2869fa2 100644
--- a/scripts/run_batch_mos_timeseries_csv.py
+++ b/scripts/run_batch_mos_timeseries_csv.py
@@ -84,8 +84,13 @@ def _make_timeseries_dataframe(
         "BOS_minY": mos.BOS_minY,
         "BOS_maxY": mos.BOS_maxY,
         "MOS_minDist_signed": mos.MOS_signed,
+        "MOS_AP_v3d": mos.MOS_AP_v3d,
+        "MOS_ML_v3d": mos.MOS_ML_v3d,
+        "MOS_v3d": mos.MOS_v3d,
         "MOS_AP_dir": mos.MOS_AP_dir,
         "MOS_ML_dir": mos.MOS_ML_dir,
+        "MOS_AP_velDir": mos.MOS_AP_velDir,
+        "MOS_ML_velDir": mos.MOS_ML_velDir,
         "Is_platform_onset_frame": is_platform_onset,
         "Is_step_onset_frame": is_step_onset,
     }
diff --git a/scripts/run_mos_pipeline.py b/scripts/run_mos_pipeline.py
index 1691cc8..ba12965 100644
--- a/scripts/run_mos_pipeline.py
+++ b/scripts/run_mos_pipeline.py
@@ -146,8 +146,13 @@ def main() -> None:
             "BOS_minY": mos.BOS_minY,
             "BOS_maxY": mos.BOS_maxY,
             "MOS_minDist_signed": mos.MOS_signed,
+            "MOS_AP_v3d": mos.MOS_AP_v3d,
+            "MOS_ML_v3d": mos.MOS_ML_v3d,
+            "MOS_v3d": mos.MOS_v3d,
             "MOS_AP_dir": mos.MOS_AP_dir,
             "MOS_ML_dir": mos.MOS_ML_dir,
+            "MOS_AP_velDir": mos.MOS_AP_velDir,
+            "MOS_ML_velDir": mos.MOS_ML_velDir,
             "Is_platform_onset_frame": is_platform_onset,
             "Is_step_onset_frame": is_step_onset,
         }
@@ -178,19 +183,31 @@ def main() -> None:
         "platform_onset_local": events.platform_onset_local,
         "step_onset_local": events.step_onset_local,
         "analysis_end_local": end_frame,
+        # Polygon-signed MoS (convex hull boundary)
         "baseline_MOS_mean": float(baseline_df.select(pl.col("MOS_minDist_signed").mean()).item()),
         "baseline_MOS_min": float(baseline_df.select(pl.col("MOS_minDist_signed").min()).item()),
         "perturb_MOS_min": float(pert_df.select(pl.col("MOS_minDist_signed").min()).item()),
+        # Visual3D original-style MoS (closest bound)
+        "baseline_MOS_v3d_mean": float(baseline_df.select(pl.col("MOS_v3d").mean()).item()),
+        "baseline_MOS_v3d_min": float(baseline_df.select(pl.col("MOS_v3d").min()).item()),
+        "perturb_MOS_v3d_min": float(pert_df.select(pl.col("MOS_v3d").min()).item()),
     }
 
     if pert_df.height > 0:
+        onset_time = float(df_pl.filter(pl.col("Is_platform_onset_frame")).select(pl.col("Time_s")).item())
+
+        # Polygon-signed MoS min
         min_row = pert_df.sort("MOS_minDist_signed").head(1)
         summary["perturb_MOS_min_frame"] = int(min_row.select(pl.col("Frame")).item())
-
-        onset_time = float(df_pl.filter(pl.col("Is_platform_onset_frame")).select(pl.col("Time_s")).item())
         min_time = float(min_row.select(pl.col("Time_s")).item())
         summary["perturb_MOS_min_time_from_onset_s"] = float(min_time - onset_time)
 
+        # Visual3D closest-bound MoS min
+        min_row_v3d = pert_df.sort("MOS_v3d").head(1)
+        summary["perturb_MOS_v3d_min_frame"] = int(min_row_v3d.select(pl.col("Frame")).item())
+        min_time_v3d = float(min_row_v3d.select(pl.col("Time_s")).item())
+        summary["perturb_MOS_v3d_min_time_from_onset_s"] = float(min_time_v3d - onset_time)
+
     # Optional V3D COM validation
     validation = None
     if args.v3d_com_xlsx:
diff --git a/src/replace_v3d/mos/core.py b/src/replace_v3d/mos/core.py
index 96b09b9..97e1e97 100644
--- a/src/replace_v3d/mos/core.py
+++ b/src/replace_v3d/mos/core.py
@@ -27,9 +27,52 @@ BOS_MARKERS_DEFAULT = [
 
 @dataclass(frozen=True)
 class MOSResult:
+    """MoS / BoS time series container.
+
+    Notes
+    -----
+    Visual3D's MoS tutorial ("Original definition") uses the distance from xCoM to
+    the *closest* BoS boundary at each frame (via the Closest_Bound meta-command).
+
+    Your old implementation used a *velocity-sign switch* (pick minX vs maxX based
+    on vCOM sign). That is not Visual3D's logic, and it produces step-like jumps
+    whenever vCOM crosses 0 (which can happen frequently due to filtering noise).
+
+    This repo now exposes:
+
+    - MOS_AP_v3d / MOS_ML_v3d / MOS_v3d:
+        Visual3D-style closest-bound distances (recommended).
+
+    - MOS_AP_dir / MOS_ML_dir:
+        Backward-compatible aliases of the Visual3D-style values above.
+        (Kept because downstream scripts/plots often referenced "*_dir".)
+
+    - MOS_AP_velDir / MOS_ML_velDir:
+        The previous velocity-switching version (debug only).
+
+    - MOS_signed:
+        Polygon-based signed min distance to the convex hull boundary (+inside).
+        This is *not* the same as Visual3D's original scalar MoS, but can be
+        useful for convex-hull distance analysis.
+    """
+
+    # Polygon signed min distance (convex hull boundary)
     MOS_signed: np.ndarray  # (T,)
+
+    # Visual3D (original) style: closest bound in each direction
+    MOS_AP_v3d: np.ndarray  # (T,)
+    MOS_ML_v3d: np.ndarray  # (T,)
+    MOS_v3d: np.ndarray  # (T,)
+
+    # Backward-compatible aliases (same as MOS_*_v3d)
     MOS_AP_dir: np.ndarray  # (T,)
     MOS_ML_dir: np.ndarray  # (T,)
+
+    # Legacy: velocity-direction based bound selection (debug; discontinuous)
+    MOS_AP_velDir: np.ndarray  # (T,)
+    MOS_ML_velDir: np.ndarray  # (T,)
+
+    # BoS geometry summaries
     BOS_area: np.ndarray  # (T,)
     BOS_minX: np.ndarray  # (T,)
     BOS_maxX: np.ndarray  # (T,)
@@ -37,6 +80,23 @@ class MOSResult:
     BOS_maxY: np.ndarray  # (T,)
 
 
+def _closest_bound_1d(x: float, xmin: float, xmax: float) -> float:
+    """Signed distance to the closest of two bounds.
+
+    Returns
+    -------
+    d : float
+        Positive if xmin <= x <= xmax, negative otherwise.
+
+    Notes
+    -----
+    This matches Visual3D's "Closest_Bound" behavior for two candidate bounds
+    at each frame (take the smaller of the two distances).
+    """
+
+    return min(x - xmin, xmax - x)
+
+
 def compute_mos_timeseries(
     points: np.ndarray,
     labels: List[str],
@@ -45,19 +105,49 @@ def compute_mos_timeseries(
     end_frame: Optional[int] = None,
     bos_markers: List[str] = BOS_MARKERS_DEFAULT,
 ) -> MOSResult:
-    """Compute MoS for each frame using:
+    """Compute MoS for each frame.
+
+    BoS
+    ---
+    - BoS polygon is the convex hull of foot-landmark markers (ground plane: X-Y)
+    - Also returns axis-aligned bounds (minX/maxX/minY/maxY) of that hull
+
+    MoS outputs
+    ---
+    - MOS_signed: signed min distance from xCOM(XY) to hull boundary (+inside)
+
+    - MOS_AP_v3d / MOS_ML_v3d:
+        Visual3D "original" style closest-bound distance.
+
+    - MOS_v3d:
+        min(MOS_AP_v3d, MOS_ML_v3d)  (closest boundary overall)
+
+    - MOS_AP_dir / MOS_ML_dir:
+        Aliases of MOS_AP_v3d / MOS_ML_v3d (for backward compatibility)
 
-    - xCOM (Hof) as the test point
-    - BoS as the convex hull of foot-landmark markers (ground plane: X-Y)
-    - MoS = signed minimum distance to the BoS boundary
+    - MOS_AP_velDir / MOS_ML_velDir:
+        Legacy velocity-direction switching (debug only)
 
     Parameters
     ----------
-    points: (T, N, 3)
-    xcom:   (T, 3)
-    vcom:   (T, 3)
-    end_frame: if provided, compute only frames [1..end_frame] (1-based)
+    points:
+        (T, N, 3)
+    labels:
+        list of marker labels of length N
+    xcom:
+        (T, 3)
+    vcom:
+        (T, 3)
+    end_frame:
+        If provided, compute only frames [1..end_frame] (1-based)
+    bos_markers:
+        Marker names used to form the BoS hull.
+
+    Returns
+    -------
+    MOSResult
     """
+
     T = points.shape[0]
     if end_frame is None:
         end = T
@@ -72,8 +162,19 @@ def compute_mos_timeseries(
         idx.append(labels.index(m))
 
     MOS_signed = np.zeros(end, dtype=float)
-    MOS_AP = np.zeros(end, dtype=float)
-    MOS_ML = np.zeros(end, dtype=float)
+
+    MOS_AP_v3d = np.zeros(end, dtype=float)
+    MOS_ML_v3d = np.zeros(end, dtype=float)
+    MOS_v3d = np.zeros(end, dtype=float)
+
+    # Backward-compat aliases (filled at the end)
+    MOS_AP_dir = np.zeros(end, dtype=float)
+    MOS_ML_dir = np.zeros(end, dtype=float)
+
+    # Legacy velocity-switching (debug)
+    MOS_AP_velDir = np.zeros(end, dtype=float)
+    MOS_ML_velDir = np.zeros(end, dtype=float)
+
     area = np.zeros(end, dtype=float)
     minX = np.zeros(end, dtype=float)
     maxX = np.zeros(end, dtype=float)
@@ -81,7 +182,7 @@ def compute_mos_timeseries(
     maxY = np.zeros(end, dtype=float)
 
     for t in range(end):
-        pts_xy = points[t, idx, :2]  # (8,2)
+        pts_xy = points[t, idx, :2]  # (M,2)
 
         hull = convex_hull_2d(pts_xy)
         area[t] = polygon_area(hull)
@@ -91,27 +192,39 @@ def compute_mos_timeseries(
         p = xcom[t, :2]
         MOS_signed[t] = signed_min_distance_point_to_polygon(p, hull)
 
-        # Directional margins (optional but useful): boundary in direction of COM velocity
-        # X axis: A/P, negative X = forward in your coordinate description.
+        # Visual3D "original" style = closest bound (no velocity switching)
+        # NOTE: In this repo's coordinate setup, X is A/P and Y is M/L (see plan.md).
+        MOS_AP_v3d[t] = _closest_bound_1d(float(p[0]), bminx, bmaxx)
+        MOS_ML_v3d[t] = _closest_bound_1d(float(p[1]), bminy, bmaxy)
+        MOS_v3d[t] = min(MOS_AP_v3d[t], MOS_ML_v3d[t])
+
+        # Legacy: velocity-direction switching (debug only)
         if vcom[t, 0] < 0:
-            MOS_AP[t] = p[0] - bminx
+            MOS_AP_velDir[t] = p[0] - bminx
         else:
-            MOS_AP[t] = bmaxx - p[0]
+            MOS_AP_velDir[t] = bmaxx - p[0]
 
-        # Y axis: M/L (sign depends on setup; keep consistent with raw data)
         if vcom[t, 1] < 0:
-            MOS_ML[t] = p[1] - bminy
+            MOS_ML_velDir[t] = p[1] - bminy
         else:
-            MOS_ML[t] = bmaxy - p[1]
+            MOS_ML_velDir[t] = bmaxy - p[1]
+
+    # Backward-compat aliases
+    MOS_AP_dir[:] = MOS_AP_v3d
+    MOS_ML_dir[:] = MOS_ML_v3d
 
     return MOSResult(
         MOS_signed=MOS_signed,
-        MOS_AP_dir=MOS_AP,
-        MOS_ML_dir=MOS_ML,
+        MOS_AP_v3d=MOS_AP_v3d,
+        MOS_ML_v3d=MOS_ML_v3d,
+        MOS_v3d=MOS_v3d,
+        MOS_AP_dir=MOS_AP_dir,
+        MOS_ML_dir=MOS_ML_dir,
+        MOS_AP_velDir=MOS_AP_velDir,
+        MOS_ML_velDir=MOS_ML_velDir,
         BOS_area=area,
         BOS_minX=minX,
         BOS_maxX=maxX,
         BOS_minY=minY,
         BOS_maxY=maxY,
     )
-
